package com.secure.ai.burp.agents;

import burp.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Tier 1: Vulnerability Validation Agent
 * 
 * Automatically confirms if vulnerabilities identified by the scanner are true positives.
 * Generates non-destructive PoC payloads and analyzes responses for confirmation indicators.
 */
public class VulnerabilityValidationAgent {
    
    private final IBurpExtenderCallbacks callbacks;
    private final ExecutorService executorService;
    
    private final AtomicInteger validationCount = new AtomicInteger(0);
    private final AtomicInteger confirmedCount = new AtomicInteger(0);
    private volatile boolean active = false;
    
    // Validation payloads for different vulnerability types
    private final Map<String, List<String>> validationPayloads;
    
    public VulnerabilityValidationAgent(IBurpExtenderCallbacks callbacks, ExecutorService executorService) {
        this.callbacks = callbacks;
        this.executorService = executorService;
        this.validationPayloads = new HashMap<>();
        
        initializeValidationPayloads();
    }
    
    private void initializeValidationPayloads() {
        // SQL Injection validation payloads (non-destructive)
        validationPayloads.put("SQL injection", Arrays.asList(
            "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 --",
            "' AND SLEEP(2) --",
            "' AND (SELECT 'test') = 'test' --",
            "1 AND (SELECT COUNT(*) FROM information_schema.schemata) > 0"
        ));
        
        // XSS validation payloads (benign)
        validationPayloads.put("Cross-site scripting", Arrays.asList(
            "<img src=x onerror=console.log('xss-test')>",
            "<script>console.log('xss-validation')</script>",
            "javascript:console.log('xss-check')",
            "<svg onload=console.log('xss-confirm')>"
        ));
        
        // LDAP injection validation
        validationPayloads.put("LDAP injection", Arrays.asList(
            "*)(uid=*))(|(uid=*",
            "*)(cn=*))(|(cn=*",
            "admin)(&(password=*)"
        ));
        
        // Command injection validation
        validationPayloads.put("OS command injection", Arrays.asList(
            "; ping -c 2 127.0.0.1",
            "| timeout 2",
            "&& echo 'validation-test'",
            "; sleep 2"
        ));
        
        // Path traversal validation
        validationPayloads.put("Path traversal", Arrays.asList(
            "../../etc/passwd",
            "..\\\\..\\\\windows\\\\win.ini",
            "%2e%2e%2fetc%2fpasswd",
            "....//....//etc//passwd"
        ));
    }
    
    public void start() {
        this.active = true;
        
        // Start monitoring scanner issues
        executorService.submit(this::monitorScannerIssues);
    }
    
    public void stop() {
        this.active = false;
    }
    
    public String getStatus() {
        return active ? "ACTIVE - Validating findings" : "STOPPED";
    }
    
    public int getValidationCount() {
        return validationCount.get();
    }
    
    public int getConfirmedCount() {
        return confirmedCount.get();
    }
    
    public void processResponse(IInterceptedProxyMessage message) {
        if (!active) return;
        
        // Analyze responses for validation indicators
        executorService.submit(() -> analyzeResponseForValidation(message));
    }
    
    private void monitorScannerIssues() {
        while (active && !Thread.currentThread().isInterrupted()) {
            try {
                // Get current scanner issues
                IScanIssue[] issues = callbacks.getScanIssues(null);
                
                for (IScanIssue issue : issues) {
                    if (shouldValidateIssue(issue)) {
                        validateIssue(issue);
                    }
                }
                
                Thread.sleep(30000); // Check every 30 seconds
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private boolean shouldValidateIssue(IScanIssue issue) {
        // Check if issue needs validation
        String issueName = issue.getIssueName();
        String confidence = issue.getConfidence();
        
        // Validate medium/firm confidence issues
        return ("Tentative".equals(confidence) || "Firm".equals(confidence)) &&
               validationPayloads.containsKey(issueName);
    }
    
    private void validateIssue(IScanIssue issue) {
        validationCount.incrementAndGet();
        
        executorService.submit(() -> {
            try {
                String issueName = issue.getIssueName();
                IHttpRequestResponse baseRequestResponse = issue.getHttpMessages()[0];
                
                // Get validation payloads for this issue type
                List<String> payloads = validationPayloads.get(issueName);
                if (payloads == null || payloads.isEmpty()) return;
                
                boolean confirmed = false;
                
                for (String payload : payloads) {
                    if (testValidationPayload(baseRequestResponse, payload, issueName)) {
                        confirmed = true;
                        break;
                    }
                }
                
                if (confirmed) {
                    confirmedCount.incrementAndGet();
                    updateIssueStatus(issue, "VALIDATED", "Confirmed via automated PoC testing");
                } else {
                    updateIssueStatus(issue, "LIKELY FALSE POSITIVE", "Could not confirm via validation testing");
                }
                
            } catch (Exception e) {
                // Log error but continue
                callbacks.printError("Validation error: " + e.getMessage());
            }
        });
    }
    
    private boolean testValidationPayload(IHttpRequestResponse baseRequest, String payload, String issueType) {
        try {
            // Create modified request with validation payload
            byte[] modifiedRequest = createValidationRequest(baseRequest.getRequest(), payload);
            
            // Send request and analyze response
            IHttpRequestResponse validationResponse = callbacks.makeHttpRequest(
                baseRequest.getHttpService(), modifiedRequest);
            
            if (validationResponse.getResponse() == null) return false;
            
            // Analyze response for validation indicators
            return analyzeValidationResponse(validationResponse.getResponse(), issueType, payload);
            
        } catch (Exception e) {
            return false;
        }
    }
    
    private byte[] createValidationRequest(byte[] originalRequest, String payload) {
        String request = new String(originalRequest);
        
        // Simple payload injection into parameters
        // In a real implementation, this would be more sophisticated
        String[] lines = request.split("\\r?\\n");
        StringBuilder modifiedRequest = new StringBuilder();
        
        for (String line : lines) {
            if (line.contains("=") && !line.startsWith("Host:") && !line.startsWith("User-Agent:")) {
                // Inject payload into parameters
                String modifiedLine = line.replaceAll("=([^&\\s]*)", "=" + payload);
                modifiedRequest.append(modifiedLine).append("\\n");
            } else {
                modifiedRequest.append(line).append("\\n");
            }
        }
        
        return modifiedRequest.toString().getBytes();
    }
    
    private boolean analyzeValidationResponse(byte[] response, String issueType, String payload) {
        String responseString = new String(response).toLowerCase();
        
        switch (issueType) {
            case "SQL injection":
                return analyzeSQLiValidationResponse(responseString, payload);
            case "Cross-site scripting":
                return analyzeXSSValidationResponse(responseString, payload);
            case "OS command injection":
                return analyzeRCEValidationResponse(responseString, payload);
            case "Path traversal":
                return analyzePathTraversalResponse(responseString, payload);
            default:
                return false;
        }
    }
    
    private boolean analyzeSQLiValidationResponse(String response, String payload) {
        // Look for SQL error messages or time delays
        return response.contains("sql syntax") ||
               response.contains("mysql_fetch") ||
               response.contains("ora-") ||
               response.contains("microsoft jet database") ||
               response.contains("sqlite") ||
               (payload.contains("SLEEP") && isDelayedResponse());
    }
    
    private boolean analyzeXSSValidationResponse(String response, String payload) {
        // Look for reflected payload or XSS indicators
        return response.contains(payload.toLowerCase()) ||
               response.contains("xss-test") ||
               response.contains("console.log") ||
               response.contains("<script") ||
               response.contains("onerror");
    }
    
    private boolean analyzeRCEValidationResponse(String response, String payload) {
        // Look for command execution indicators
        return response.contains("validation-test") ||
               response.contains("ping") ||
               response.contains("timeout") ||
               (payload.contains("sleep") && isDelayedResponse());
    }
    
    private boolean analyzePathTraversalResponse(String response, String payload) {
        // Look for file content indicators
        return response.contains("root:") ||
               response.contains("[boot loader]") ||
               response.contains("/bin/sh") ||
               response.contains("windows nt") ||
               response.contains("system32");
    }
    
    private boolean isDelayedResponse() {
        // Simple time-based detection would need more sophisticated implementation
        // This is a placeholder for actual timing analysis
        return false;
    }
    
    private void updateIssueStatus(IScanIssue issue, String status, String details) {
        // In a real implementation, this would update the issue in Burp's issue list
        // For now, we'll just log it
        callbacks.printOutput(String.format("Issue Validation: %s - %s - %s", 
            issue.getIssueName(), status, details));
    }
    
    private void analyzeResponseForValidation(IInterceptedProxyMessage message) {
        // Analyze responses for signs of successful validation
        // This would look for timing anomalies, error messages, etc.
    }
    
    public void validateAllPendingIssues() {
        executorService.submit(() -> {
            IScanIssue[] issues = callbacks.getScanIssues(null);
            int pendingCount = 0;
            
            for (IScanIssue issue : issues) {
                if (shouldValidateIssue(issue)) {
                    validateIssue(issue);
                    pendingCount++;
                }
            }
            
            callbacks.printOutput("Started validation for " + pendingCount + " pending issues");
        });
    }
}