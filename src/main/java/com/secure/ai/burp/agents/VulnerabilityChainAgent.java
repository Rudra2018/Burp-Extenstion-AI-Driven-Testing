package com.secure.ai.burp.agents;

import burp.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Tier 3: Vulnerability Chaining Agent
 * 
 * Identifies opportunities to chain multiple vulnerabilities for high-impact exploit scenarios.
 * Creates attack chains that combine different vulnerability types for maximum effectiveness.
 */
public class VulnerabilityChainAgent {
    
    private final IBurpExtenderCallbacks callbacks;
    private final ExecutorService executorService;
    
    private final AtomicInteger chainCount = new AtomicInteger(0);
    private final AtomicInteger exploitChains = new AtomicInteger(0);
    private volatile boolean active = false;
    
    // Vulnerability analysis and chaining
    private final Map<String, VulnerabilityNode> vulnerabilityGraph = new ConcurrentHashMap<>();
    private final List<AttackChain> identifiedChains = new ArrayList<>();
    private final Map<String, ChainTemplate> chainTemplates;
    
    public VulnerabilityChainAgent(IBurpExtenderCallbacks callbacks, ExecutorService executorService) {
        this.callbacks = callbacks;
        this.executorService = executorService;
        this.chainTemplates = initializeChainTemplates();
    }
    
    public void start() {
        this.active = true;
        
        // Start vulnerability analysis
        executorService.submit(this::analyzeVulnerabilities);
        
        // Start chain discovery
        executorService.submit(this::discoverAttackChains);
        
        // Start chain validation
        executorService.submit(this::validateAttackChains);
    }
    
    public void stop() {
        this.active = false;
    }
    
    public String getStatus() {
        return active ? "CHAINING - " + exploitChains.get() + " chains found" : "STOPPED";
    }
    
    public int getChainCount() {
        return chainCount.get();
    }
    
    public int getExploitChains() {
        return exploitChains.get();
    }
    
    private Map<String, ChainTemplate> initializeChainTemplates() {
        Map<String, ChainTemplate> templates = new HashMap<>();
        
        // SSRF -> RCE Chain
        templates.put("SSRF_RCE", new ChainTemplate(
            "SSRF to RCE",
            "Server-Side Request Forgery leading to Remote Code Execution",
            Arrays.asList("Server-side request forgery", "OS command injection"),
            this::validateSsrfRceChain,
            "Use SSRF to access internal services that allow command execution"
        ));
        
        // SQLi -> File Write -> RCE Chain
        templates.put("SQLI_FILE_RCE", new ChainTemplate(
            "SQL Injection to RCE via File Write",
            "SQL injection with file write capabilities leading to code execution",
            Arrays.asList("SQL injection", "File upload vulnerability"),
            this::validateSqlFileRceChain,
            "Use SQL injection to write malicious files, then execute via file upload"
        ));
        
        // XSS -> CSRF -> Privilege Escalation Chain
        templates.put("XSS_CSRF_PRIVESC", new ChainTemplate(
            "XSS to Privilege Escalation via CSRF",
            "Cross-site scripting enabling CSRF attacks for privilege escalation",
            Arrays.asList("Cross-site scripting", "Cross-site request forgery"),
            this::validateXssCsrfPrivescChain,
            "Use XSS to perform CSRF attacks that elevate user privileges"
        ));
        
        // IDOR -> Information Disclosure -> Account Takeover Chain
        templates.put("IDOR_INFO_TAKEOVER", new ChainTemplate(
            "IDOR to Account Takeover",
            "Insecure Direct Object Reference leading to account compromise",
            Arrays.asList("Insecure direct object references", "Information disclosure"),
            this::validateIdorInfoTakeoverChain,
            "Use IDOR to access sensitive user information for account takeover"
        ));
        
        // Path Traversal -> Configuration Disclosure -> Authentication Bypass Chain
        templates.put("LFI_CONFIG_AUTHBYPASS", new ChainTemplate(
            "Path Traversal to Authentication Bypass",
            "Path traversal revealing configuration leading to authentication bypass",
            Arrays.asList("Path traversal", "Information disclosure"),
            this::validateLfiConfigAuthBypassChain,
            "Use path traversal to read configuration files containing authentication secrets"
        ));
        
        // Weak Session -> Session Fixation -> Account Hijacking Chain
        templates.put("WEAK_SESSION_HIJACK", new ChainTemplate(
            "Weak Session Management to Account Hijacking",
            "Weak session handling enabling complete account compromise",
            Arrays.asList("Session fixation", "Weak session management"),
            this::validateWeakSessionHijackChain,
            "Exploit weak session management to hijack user accounts"
        ));
        
        // XXE -> SSRF -> Internal Network Access Chain
        templates.put("XXE_SSRF_INTERNAL", new ChainTemplate(
            "XXE to Internal Network Access",
            "XML External Entity processing enabling internal network reconnaissance",
            Arrays.asList("XML external entity", "Server-side request forgery"),
            this::validateXxeSsrfInternalChain,
            "Use XXE to perform SSRF attacks against internal network resources"
        ));
        
        return templates;
    }
    
    private void analyzeVulnerabilities() {
        while (active && !Thread.currentThread().isInterrupted()) {
            try {
                // Get current scanner issues
                IScanIssue[] issues = callbacks.getScanIssues(null);
                
                // Build vulnerability graph
                for (IScanIssue issue : issues) {
                    addVulnerabilityToGraph(issue);
                }
                
                Thread.sleep(60000); // Analyze every minute
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private void addVulnerabilityToGraph(IScanIssue issue) {
        try {
            String nodeId = generateNodeId(issue);
            
            if (!vulnerabilityGraph.containsKey(nodeId)) {
                VulnerabilityNode node = new VulnerabilityNode();
                node.issue = issue;
                node.type = issue.getIssueName();
                node.host = issue.getUrl().getHost();
                node.path = issue.getUrl().getPath();
                node.confidence = issue.getConfidence();
                node.severity = issue.getSeverity();
                node.timestamp = System.currentTimeMillis();
                
                // Extract additional metadata
                node.parameters = extractParameters(issue);
                node.httpMethods = extractHttpMethods(issue);
                node.vulnerableParameter = extractVulnerableParameter(issue);
                
                vulnerabilityGraph.put(nodeId, node);
            }
            
        } catch (Exception e) {
            // Continue processing other vulnerabilities
        }
    }
    
    private void discoverAttackChains() {
        while (active && !Thread.currentThread().isInterrupted()) {
            try {
                Thread.sleep(120000); // Wait 2 minutes for vulnerability accumulation
                
                // Look for chain opportunities
                for (ChainTemplate template : chainTemplates.values()) {
                    List<AttackChain> newChains = findChainsForTemplate(template);
                    
                    for (AttackChain chain : newChains) {
                        if (!isDuplicateChain(chain)) {
                            identifiedChains.add(chain);
                            chainCount.incrementAndGet();
                            
                            callbacks.printOutput("ATTACK CHAIN DISCOVERED: " + template.name + 
                                                 " on " + chain.targetHost);
                        }
                    }
                }
                
                Thread.sleep(300000); // Discover chains every 5 minutes
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private List<AttackChain> findChainsForTemplate(ChainTemplate template) {
        List<AttackChain> chains = new ArrayList<>();
        
        // Group vulnerabilities by host
        Map<String, List<VulnerabilityNode>> vulnsByHost = new HashMap<>();
        
        for (VulnerabilityNode node : vulnerabilityGraph.values()) {
            vulnsByHost.computeIfAbsent(node.host, k -> new ArrayList<>()).add(node);
        }
        
        // Look for chain patterns on each host
        for (Map.Entry<String, List<VulnerabilityNode>> entry : vulnsByHost.entrySet()) {
            String host = entry.getKey();
            List<VulnerabilityNode> hostVulns = entry.getValue();
            
            AttackChain chain = findChainInVulnerabilities(template, host, hostVulns);
            if (chain != null) {
                chains.add(chain);
            }
        }
        
        return chains;
    }
    
    private AttackChain findChainInVulnerabilities(ChainTemplate template, String host, List<VulnerabilityNode> vulnerabilities) {
        Map<String, VulnerabilityNode> requiredVulns = new HashMap<>();
        
        // Check if all required vulnerability types are present
        for (String requiredType : template.requiredVulnerabilityTypes) {
            VulnerabilityNode matchingVuln = vulnerabilities.stream()
                .filter(v -> v.type.contains(requiredType) || requiredType.contains(v.type))
                .findFirst()
                .orElse(null);
            
            if (matchingVuln == null) {
                return null; // Missing required vulnerability type
            }
            
            requiredVulns.put(requiredType, matchingVuln);
        }
        
        // Create attack chain
        AttackChain chain = new AttackChain();
        chain.template = template;
        chain.targetHost = host;
        chain.vulnerabilities = new ArrayList<>(requiredVulns.values());
        chain.feasibilityScore = calculateFeasibilityScore(chain);
        chain.impactScore = calculateImpactScore(chain);
        chain.timestamp = System.currentTimeMillis();
        
        return chain;
    }
    
    private void validateAttackChains() {
        while (active && !Thread.currentThread().isInterrupted()) {
            try {
                Thread.sleep(180000); // Wait 3 minutes before validation
                
                List<AttackChain> chainsToValidate = new ArrayList<>(identifiedChains);
                
                for (AttackChain chain : chainsToValidate) {
                    if (!active) break;
                    
                    if (chain.validationStatus == ValidationStatus.PENDING) {
                        validateChain(chain);
                    }
                }
                
                Thread.sleep(600000); // Validate every 10 minutes
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private void validateChain(AttackChain chain) {
        executorService.submit(() -> {
            try {
                boolean isValid = chain.template.validationFunction.apply(chain);
                
                if (isValid) {
                    chain.validationStatus = ValidationStatus.VALID;
                    exploitChains.incrementAndGet();
                    
                    callbacks.printOutput("VALIDATED EXPLOIT CHAIN: " + chain.template.name + 
                                         " (Feasibility: " + chain.feasibilityScore + 
                                         ", Impact: " + chain.impactScore + ")");
                } else {
                    chain.validationStatus = ValidationStatus.INVALID;
                }
                
            } catch (Exception e) {
                chain.validationStatus = ValidationStatus.ERROR;
                callbacks.printError("Chain validation error: " + e.getMessage());
            }
        });
    }
    
    // Chain Validation Functions
    
    private boolean validateSsrfRceChain(AttackChain chain) {
        // Validate SSRF can reach internal services that accept commands
        VulnerabilityNode ssrf = findVulnerabilityByType(chain, "Server-side request forgery");
        VulnerabilityNode rce = findVulnerabilityByType(chain, "OS command injection");
        
        if (ssrf != null && rce != null) {
            // Check if SSRF can access internal network ranges
            return isInternalNetworkAccessible(ssrf) && canExecuteCommands(rce);
        }
        
        return false;
    }
    
    private boolean validateSqlFileRceChain(AttackChain chain) {
        VulnerabilityNode sqli = findVulnerabilityByType(chain, "SQL injection");
        VulnerabilityNode upload = findVulnerabilityByType(chain, "File upload");
        
        if (sqli != null && upload != null) {
            return canWriteFiles(sqli) && canExecuteUploadedFiles(upload);
        }
        
        return false;
    }
    
    private boolean validateXssCsrfPrivescChain(AttackChain chain) {
        VulnerabilityNode xss = findVulnerabilityByType(chain, "Cross-site scripting");
        VulnerabilityNode csrf = findVulnerabilityByType(chain, "Cross-site request forgery");
        
        if (xss != null && csrf != null) {
            return isStoredXss(xss) && affectsPrivilegedFunctions(csrf);
        }
        
        return false;
    }
    
    private boolean validateIdorInfoTakeoverChain(AttackChain chain) {
        VulnerabilityNode idor = findVulnerabilityByType(chain, "Insecure direct object references");
        VulnerabilityNode info = findVulnerabilityByType(chain, "Information disclosure");
        
        if (idor != null && info != null) {
            return exposesUserData(idor) && containsSensitiveInfo(info);
        }
        
        return false;
    }
    
    private boolean validateLfiConfigAuthBypassChain(AttackChain chain) {
        VulnerabilityNode lfi = findVulnerabilityByType(chain, "Path traversal");
        VulnerabilityNode info = findVulnerabilityByType(chain, "Information disclosure");
        
        if (lfi != null && info != null) {
            return canAccessConfigFiles(lfi) && exposesAuthSecrets(info);
        }
        
        return false;
    }
    
    private boolean validateWeakSessionHijackChain(AttackChain chain) {
        VulnerabilityNode session = findVulnerabilityByType(chain, "Session");
        
        if (session != null) {
            return hasWeakSessionManagement(session);
        }
        
        return false;
    }
    
    private boolean validateXxeSsrfInternalChain(AttackChain chain) {
        VulnerabilityNode xxe = findVulnerabilityByType(chain, "XML external entity");
        VulnerabilityNode ssrf = findVulnerabilityByType(chain, "Server-side request forgery");
        
        if (xxe != null) {
            return canPerformXxeRequests(xxe);
        }
        
        return false;
    }
    
    // Helper validation methods (simplified implementations)
    
    private VulnerabilityNode findVulnerabilityByType(AttackChain chain, String type) {
        return chain.vulnerabilities.stream()
                   .filter(v -> v.type.toLowerCase().contains(type.toLowerCase()))
                   .findFirst()
                   .orElse(null);
    }
    
    private boolean isInternalNetworkAccessible(VulnerabilityNode ssrf) {
        // Check if SSRF can access internal IP ranges
        String issueDetail = ssrf.issue.getIssueDetail();
        return issueDetail != null && (issueDetail.contains("127.0.0.1") || 
                                     issueDetail.contains("192.168.") || 
                                     issueDetail.contains("10."));
    }
    
    private boolean canExecuteCommands(VulnerabilityNode rce) {
        // Check if RCE vulnerability allows command execution
        return "High".equals(rce.severity) && "Firm".equals(rce.confidence);
    }
    
    private boolean canWriteFiles(VulnerabilityNode sqli) {
        String detail = sqli.issue.getIssueDetail();
        return detail != null && (detail.toLowerCase().contains("into outfile") || 
                                detail.toLowerCase().contains("dumpfile"));
    }
    
    private boolean canExecuteUploadedFiles(VulnerabilityNode upload) {
        return upload.path.toLowerCase().contains("upload") || 
               upload.path.toLowerCase().contains("file");
    }
    
    private boolean isStoredXss(VulnerabilityNode xss) {
        return xss.issue.getIssueDetail() != null && 
               xss.issue.getIssueDetail().toLowerCase().contains("stored");
    }
    
    private boolean affectsPrivilegedFunctions(VulnerabilityNode csrf) {
        return csrf.path.toLowerCase().contains("admin") || 
               csrf.path.toLowerCase().contains("manage");
    }
    
    private boolean exposesUserData(VulnerabilityNode idor) {
        return idor.vulnerableParameter != null && 
               (idor.vulnerableParameter.contains("user") || 
                idor.vulnerableParameter.contains("id"));
    }
    
    private boolean containsSensitiveInfo(VulnerabilityNode info) {
        String detail = info.issue.getIssueDetail();
        return detail != null && 
               (detail.contains("password") || detail.contains("email") || detail.contains("token"));
    }
    
    private boolean canAccessConfigFiles(VulnerabilityNode lfi) {
        String detail = lfi.issue.getIssueDetail();
        return detail != null && 
               (detail.contains("config") || detail.contains("web.xml") || detail.contains(".env"));
    }
    
    private boolean exposesAuthSecrets(VulnerabilityNode info) {
        String detail = info.issue.getIssueDetail();
        return detail != null && 
               (detail.contains("secret") || detail.contains("key") || detail.contains("token"));
    }
    
    private boolean hasWeakSessionManagement(VulnerabilityNode session) {
        return "High".equals(session.severity) || "Medium".equals(session.severity);
    }
    
    private boolean canPerformXxeRequests(VulnerabilityNode xxe) {
        return "High".equals(xxe.severity) && "Firm".equals(xxe.confidence);
    }
    
    // Helper methods
    
    private double calculateFeasibilityScore(AttackChain chain) {
        double score = 0.0;
        
        for (VulnerabilityNode vuln : chain.vulnerabilities) {
            // Higher score for high confidence vulnerabilities
            if ("Firm".equals(vuln.confidence)) score += 0.4;
            else if ("Tentative".equals(vuln.confidence)) score += 0.2;
            
            // Higher score for high severity vulnerabilities
            if ("High".equals(vuln.severity)) score += 0.3;
            else if ("Medium".equals(vuln.severity)) score += 0.2;
            else if ("Low".equals(vuln.severity)) score += 0.1;
        }
        
        // Normalize to 0-1 range
        return Math.min(1.0, score / chain.vulnerabilities.size());
    }
    
    private double calculateImpactScore(AttackChain chain) {
        Map<String, Double> impactValues = Map.of(
            "OS command injection", 1.0,
            "SQL injection", 0.9,
            "Cross-site scripting", 0.7,
            "Path traversal", 0.6,
            "Server-side request forgery", 0.8
        );
        
        double maxImpact = 0.0;
        for (VulnerabilityNode vuln : chain.vulnerabilities) {
            Double impact = impactValues.entrySet().stream()
                .filter(entry -> vuln.type.contains(entry.getKey()))
                .map(Map.Entry::getValue)
                .findFirst()
                .orElse(0.5);
            
            maxImpact = Math.max(maxImpact, impact);
        }
        
        return maxImpact;
    }
    
    private boolean isDuplicateChain(AttackChain newChain) {
        return identifiedChains.stream()
                              .anyMatch(existing -> 
                                  existing.template.name.equals(newChain.template.name) &&
                                  existing.targetHost.equals(newChain.targetHost));
    }
    
    private String generateNodeId(IScanIssue issue) {
        return issue.getIssueName() + "_" + issue.getUrl().getHost() + "_" + 
               issue.getUrl().getPath() + "_" + 
               (issue.getIssueDetail() != null ? issue.getIssueDetail().hashCode() : "");
    }
    
    private List<String> extractParameters(IScanIssue issue) {
        List<String> parameters = new ArrayList<>();
        
        if (issue.getHttpMessages() != null && issue.getHttpMessages().length > 0) {
            IRequestInfo reqInfo = callbacks.getHelpers().analyzeRequest(issue.getHttpMessages()[0]);
            
            for (IParameter param : reqInfo.getParameters()) {
                parameters.add(param.getName());
            }
        }
        
        return parameters;
    }
    
    private List<String> extractHttpMethods(IScanIssue issue) {
        List<String> methods = new ArrayList<>();
        
        if (issue.getHttpMessages() != null && issue.getHttpMessages().length > 0) {
            IRequestInfo reqInfo = callbacks.getHelpers().analyzeRequest(issue.getHttpMessages()[0]);
            methods.add(reqInfo.getMethod());
        }
        
        return methods;
    }
    
    private String extractVulnerableParameter(IScanIssue issue) {
        String detail = issue.getIssueDetail();
        if (detail != null && detail.contains("parameter")) {
            // Simple extraction of parameter name from issue detail
            String[] words = detail.split("\\s+");
            for (int i = 0; i < words.length - 1; i++) {
                if (words[i].toLowerCase().contains("parameter")) {
                    return words[i + 1].replaceAll("[^a-zA-Z0-9_]", "");
                }
            }
        }
        return null;
    }
    
    public void showAttackChains() {
        StringBuilder report = new StringBuilder();
        report.append("VULNERABILITY ATTACK CHAINS\n");
        report.append("============================\n\n");
        
        Map<ValidationStatus, List<AttackChain>> chainsByStatus = new HashMap<>();
        
        for (AttackChain chain : identifiedChains) {
            chainsByStatus.computeIfAbsent(chain.validationStatus, k -> new ArrayList<>()).add(chain);
        }
        
        for (Map.Entry<ValidationStatus, List<AttackChain>> entry : chainsByStatus.entrySet()) {
            report.append(entry.getKey()).append(" CHAINS:\n");
            
            for (AttackChain chain : entry.getValue()) {
                report.append("  - ").append(chain.template.name).append(" on ").append(chain.targetHost).append("\n");
                report.append("    Feasibility: ").append(String.format("%.2f", chain.feasibilityScore)).append("/1.0\n");
                report.append("    Impact: ").append(String.format("%.2f", chain.impactScore)).append("/1.0\n");
                report.append("    Description: ").append(chain.template.description).append("\n");
                report.append("    Attack Strategy: ").append(chain.template.attackStrategy).append("\n");
                report.append("    Vulnerabilities involved: ").append(chain.vulnerabilities.size()).append("\n\n");
            }
            report.append("\n");
        }
        
        if (identifiedChains.isEmpty()) {
            report.append("No attack chains identified yet. Wait for vulnerability analysis to complete.\n");
        } else {
            report.append("Total chains identified: ").append(chainCount.get()).append("\n");
            report.append("Validated exploit chains: ").append(exploitChains.get()).append("\n");
        }
        
        callbacks.printOutput(report.toString());
    }
    
    // Supporting data classes
    
    private static class VulnerabilityNode {
        public IScanIssue issue;
        public String type;
        public String host;
        public String path;
        public String confidence;
        public String severity;
        public long timestamp;
        public List<String> parameters;
        public List<String> httpMethods;
        public String vulnerableParameter;
    }
    
    private static class AttackChain {
        public ChainTemplate template;
        public String targetHost;
        public List<VulnerabilityNode> vulnerabilities;
        public double feasibilityScore;
        public double impactScore;
        public ValidationStatus validationStatus = ValidationStatus.PENDING;
        public long timestamp;
    }
    
    private static class ChainTemplate {
        public String name;
        public String description;
        public List<String> requiredVulnerabilityTypes;
        public java.util.function.Function<AttackChain, Boolean> validationFunction;
        public String attackStrategy;
        
        public ChainTemplate(String name, String description, List<String> requiredTypes,
                           java.util.function.Function<AttackChain, Boolean> validationFunction,
                           String attackStrategy) {
            this.name = name;
            this.description = description;
            this.requiredVulnerabilityTypes = requiredTypes;
            this.validationFunction = validationFunction;
            this.attackStrategy = attackStrategy;
        }
    }
    
    private enum ValidationStatus {
        PENDING, VALID, INVALID, ERROR
    }
}